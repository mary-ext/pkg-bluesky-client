// deno-lint-ignore-file prefer-const

import $ from 'jsr:@david/dax@~0.39.2';

import fg from 'npm:fast-glob@^3.3.2';

const toUpper = (s) => {
	return (toUpper.c[s] ??= s[0].toUpperCase() + s.slice(1));
};
const toNamespace = (s) => {
	return (toNamespace.c[s] ??= s.replace(/^\w|\.\w/g, (m) => m[m.length === 1 ? 0 : 1].toUpperCase()));
};

toUpper.c = {};
toNamespace.c = {};

const writeJsdoc = (descriptions) => {
	const len = descriptions.length;

	if (len === 0) {
		return '';
	}

	if (len === 1) {
		return `\n/** ${descriptions[0]} */\n`;
	}

	let jsdoc = '\n/**';

	for (let idx = 0; idx < len; idx++) {
		const suffix = idx !== len - 1 && descriptions[idx + 1][0] !== '@';
		jsdoc += `\n * ${descriptions[idx]}${suffix ? ` \\` : ''}`;
	}

	jsdoc += `\n */\n`;
	return jsdoc;
};

const resolveType = (nsid, def) => {
	const type = def.type;

	/** @type {string[]} */
	let descs = [];
	let val = 'unknown';

	if (def.description) {
		descs.push(def.description);

		if (def.description.toLowerCase().startsWith('deprecated')) {
			descs.push(`@deprecated`);
		}
	}

	if (type === 'unknown') {
		val = 'unknown';
	} else if (type === 'cid-link') {
		val = 'At.CIDLink';
	} else if (type === 'integer') {
		val = 'number';

		if (def.minimum !== undefined) {
			descs.push(`Minimum: ${def.minimum}`);
		}

		if (def.maximum !== undefined) {
			descs.push(`Maximum: ${def.maximum}`);
		}

		if (def.default !== undefined) {
			descs.push(`@default ${def.default}`);
		}
	} else if (type === 'boolean') {
		val = 'boolean';

		if (def.default !== undefined) {
			descs.push(`@default ${def.default}`);
		}
	} else if (type === 'string') {
		const enums = def.enum;
		const known = def.knownValues;
		const format = def.format;

		if (format !== undefined) {
			if (format === 'did') {
				val = 'At.DID';
			} else if (format === 'cid') {
				val = 'At.CID';
			} else if (format === 'handle') {
				val = 'At.Handle';
			} else if (format === 'at-uri') {
				val = 'At.Uri';
			} else if (
				format === 'at-identifier' ||
				format === 'datetime' ||
				format === 'language' ||
				format === 'nsid' ||
				format === 'uri'
			) {
				// deliberately ignored
				val = 'string';
			} else {
				console.warn(`${nsid}: unknown format ${format}`);
				val = 'string';
			}
		} else {
			if (def.minLength !== undefined) {
				descs.push(`Minimum string length: ${def.minLength}`);
			}

			if (def.maxLength !== undefined) {
				descs.push(`Maximum string length: ${def.maxLength}`);
			}

			if (def.maxGraphemes !== undefined) {
				descs.push(`Maximum grapheme length: ${def.maxGraphemes}`);
			}

			if (def.default !== undefined) {
				descs.push(`@default ${JSON.stringify(def.default)}`);
			}

			if (enums) {
				val = enums.map((val) => JSON.stringify(val)).join('|');
			} else if (known) {
				val = `${known.map((val) => JSON.stringify(val)).join('|')} | (string & {})`;
			} else {
				val = 'string';
			}
		}
	} else if (type === 'array') {
		const { value, descriptions } = resolveType(`${nsid}/0`, def.items);

		if (def.minLength !== undefined) {
			descs.push(`Minimum array length: ${def.minLength}`);
		}

		if (def.maxLength !== undefined) {
			descs.push(`Maximum array length: ${def.maxLength}`);
		}

		val = `(${value})[]`;
		descs = descs.concat(descriptions);
	} else if (type === 'blob') {
		const accept = def.accept?.map((mime) => `\`${mime.replaceAll('*', '${string}')}\``);
		val = `At.Blob${accept ? `<${accept.join('|')}>` : ''}`;
	} else if (type === 'ref') {
		const [ns, ref] = def.ref.split('#');
		val = (ns ? toNamespace(ns) + '.' : '') + (ref ? toUpper(ref) : 'Main');
	} else if (type === 'union') {
		const refs = def.refs.map((raw) => {
			const [ns, ref] = raw.split('#');
			return (ns ? toNamespace(ns) + '.' : '') + (ref ? toUpper(ref) : 'Main');
		});

		val = `Brand.Union<${refs.join('|')}>`;
	} else if (type === 'object' || type === 'params') {
		const required = def.required;
		const properties = def.properties;

		let chunk = '{';

		for (const prop in properties) {
			const optional = !required || !required.includes(prop);
			const { value, descriptions } = resolveType(`${nsid}/${prop}`, properties[prop]);

			chunk += writeJsdoc(descriptions);
			chunk += `${prop}${optional ? '?' : ''}:${value};`;
		}

		chunk += '}';
		val = chunk;
	} else {
		console.log(`${nsid}: unknown type ${type}`);
	}

	return { value: val, descriptions: descs };
};

const outfile = 'lib/lexicons.ts';

let code = `// deno-lint-ignore-file
// This file is automatically generated, do not edit!

export declare namespace Brand {
	const Type: unique symbol;

	type GetType<T extends { [Type]?: string }> = NonNullable<T[typeof Type]>;

	type Union<T extends { [Type]?: string }> = T extends any ? T & { $type: GetType<T> } : never;
}

export declare namespace At {
	type CID = string;

	type DID = \`did:\${string}\`;

	type Handle = string;

	type Uri = string;

	interface CIDLink {
		$link: CID;
	}

	interface Blob<T extends string = string> {
		$type: 'blob';
		mimeType: T;
		ref: {
			$link: string;
		};
		size: number;
	}
}

`;

// const queries = [];
// const procedures = [];
let queries = '';
let procedures = '';

const collator = new Intl.Collator('en-US');

for (const filename of fg.sync('lexicons/**/*.json').sort((a, b) => collator.compare(a, b))) {
	const jsonString = Deno.readTextFileSync(filename);
	const json = JSON.parse(jsonString);

	const ns = json.id;
	const tsNamespace = toNamespace(ns);

	const descs = [];

	let chunk = '';

	const definitions = json.defs;
	for (const key in definitions) {
		const def = definitions[key];
		const type = def.type;

		const nsid = `${ns}${key !== 'main' ? `#${key}` : ''}`;
		const typeName = key[0].toUpperCase() + key.slice(1);

		if (type === 'string') {
			const { value, descriptions } = resolveType(nsid, def);

			chunk += writeJsdoc(descriptions);
			chunk += `type ${typeName} = ${value};`;
		} else if (type === 'token') {
			chunk += `type ${typeName} = '${nsid}';`;
		} else if (type === 'object') {
			const required = def.required;
			const properties = def.properties;

			const descs = [];

			if (def.description) {
				descs.push(def.description);

				if (def.description.toLowerCase().startsWith('deprecated')) {
					descs.push(`@deprecated`);
				}
			}

			chunk += writeJsdoc(descs);
			chunk += `interface ${typeName} {`;
			chunk += `[Brand.Type]?: '${nsid}';`;

			for (const prop in properties) {
				const optional = !required || !required.includes(prop);
				const { value, descriptions } = resolveType(`${nsid}/${prop}`, properties[prop]);

				chunk += writeJsdoc(descriptions);
				chunk += `${prop}${optional ? '?' : ''}:${value};`;
			}

			chunk += '}';
		} else if (type === 'array') {
			const { value, descriptions } = resolveType(nsid, def.items);
			const descs = [];

			if (def.minLength !== undefined) {
				descs.push(`Minimum array length: ${def.minimumLength}`);
			}

			if (def.maxLength !== undefined) {
				descs.push(`Maximum array length: ${def.maxLength}`);
			}

			chunk += writeJsdoc(descs.concat(descriptions));
			chunk += `type ${typeName} = (${value})[];`;
		} else if (type === 'record') {
			const { value, descriptions } = resolveType(nsid, def.record);

			chunk += writeJsdoc(descriptions);
			chunk += `interface Record`;
			chunk += value;
		} else if (type === 'query' || type === 'procedure') {
			let parameters = def.parameters;
			let input = def.input;
			let output = def.output;
			let errors = def.errors;

			if (def.description) {
				descs.push(def.description);

				if (def.description.toLowerCase().startsWith('deprecated')) {
					descs.push(`@deprecated`);
				}
			}

			if (parameters) {
				if (Object.values(parameters.properties) === 0) {
					parameters = undefined;
				} else {
					const { value, descriptions } = resolveType(nsid, parameters);

					chunk += writeJsdoc(descriptions);
					chunk += `interface Params ${value}`;
				}
			} else {
				chunk += `interface Params {}`;
			}

			if (input) {
				if (input.encoding === 'application/json') {
					const { value, descriptions } = resolveType(nsid, input.schema);

					chunk += writeJsdoc(descriptions);

					if (input.schema.type === 'object') {
						chunk += `interface Input ${value}`;
					} else {
						chunk += `type Input = ${value};`;
					}
				} else {
					chunk += `type Input = Blob | ArrayBufferView;`;
				}
			} else {
				chunk += `type Input = undefined;`;
			}

			if (output) {
				if (output.encoding === 'application/json') {
					const { value, descriptions } = resolveType(nsid, output.schema);

					chunk += writeJsdoc(descriptions);

					if (output.schema.type === 'object') {
						chunk += `interface Output ${value}`;
					} else {
						chunk += `type Output = ${value};`;
					}
				} else {
					chunk += `type Output = Uint8Array;`;
				}
			} else {
				chunk += `type Output = undefined;`;
			}

			if (errors) {
				chunk += `interface Errors {`;

				for (const error of errors) {
					chunk += `${error.name}: {};`;
				}

				chunk += '}';
			}

			{
				let rc = `'${ns}':{\n`;

				if (parameters) {
					rc += `params: ${tsNamespace}.Params;`;
				}
				if (input) {
					rc += `input: ${tsNamespace}.Input;`;
				}
				if (output) {
					rc += `output: ${tsNamespace}.Output;`;
				}

				rc += '};';

				if (type === 'query') {
					queries += rc;
				} else if (type === 'procedure') {
					procedures += rc;
				}
			}
		} else {
			console.log(`${nsid}: unhandled type ${type}`);
		}
	}

	code += writeJsdoc(descs);
	code += `export declare namespace ${tsNamespace} {`;
	code += chunk;
	code += `}\n\n`;
}

code += `export declare interface Queries {${queries}}\n\n`;
code += `export declare interface Procedures {${procedures}}\n\n`;

console.log(`writing file`);
Deno.writeTextFileSync(outfile, code);

console.log(`running deno fmt`);
await $`deno fmt -q ${outfile}`;
